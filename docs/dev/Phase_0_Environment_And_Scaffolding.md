# Execution Document – Phase 0: Environment and Scaffolding

Status: Draft  
Audience: ARIS C# Implementation Engineer (Claude Code), human reviewers  
Related docs: ARIS_High_Level_Design_SDD.md, ARIS_Backend_SDD.md, Initial Prompt / AI Role Instruction

---

## 1. Purpose and Scope

This document defines **Phase 0 – Environment and Scaffolding** for the ARIS C# rewrite.

**Goal of this phase:**  
Create a working solution skeleton (backend, host, frontend, tests) that:

- Compiles successfully.
- Can be published as a **single-file, self-contained** Windows x64 build at least once.
- Establishes **logging, configuration, and tool extraction** scaffolding in line with the backend SDD, but **without fully wiring individual tools** (Retoc, UAssetAPI, UWPDumper, DLL Injector) yet.
- Provides a minimal WebView2 host + frontend scaffold (React/TS/Tailwind) as a base for later phases.

No Unreal-specific behavior or real tool execution should be implemented in this phase.

---

## 2. Preconditions

Before executing this phase, the environment should have:

- **.NET 8 SDK** installed.
- **Node.js + npm** installed (for React tooling).
- **Visual Studio Code** with:
  - C# / .NET tooling.
  - Claude Code extension (for this assistant).
- Git repo initialized for this project (optional but recommended).

If any of these are missing, pause and correct the environment before proceeding.

---

## 3. Target Solution Layout (Phase 0)

Phase 0 defines a **minimal but layered** solution layout that aligns with the Backend SDD while satisfying the original Phase 0 bullet plan.

Use this **folder and project structure**:

```
/ (repo root)
  src/
    ARIS.sln                      // main solution (backend + host)
    Aris.Core/                    // domain primitives, value objects, errors
    Aris.Application/             // use-cases, orchestrations, progress, transactions
    Aris.Infrastructure/          // filesystem, process, compression, crypto, logging, settings stores
    Aris.Adapters/                // tool-specific adapters (empty skeletons in Phase 0)
    Aris.Hosting/                 // composition root, DI, configuration, single-file host, IPC/HTTP bridge
    Aris.Contracts/               // DTOs shared with frontend (initially minimal)
    Aris.Tools/                   // embedded binaries/resources packaging helpers (manifest stub only)
    ARIS.UI/                      // WebView2 desktop host for the frontend

  tests/
    Aris.Core.Tests/              // xUnit tests for core + application
    ARIS.UI.Tests/                // xUnit tests for host/UI wiring/IPC

  frontend/
    package.json                  // React/TS/Tailwind + build scripts
    tsconfig.json
    tailwind.config.js
    postcss.config.cjs (if needed)
    index.html                    // entry HTML
    src/                          // React/TS source (Phase 0: placeholder app)
    public/                       // static assets
    dist/                         // build output (ignored in VCS, generated by build)
````

**Notes:**

* The original shorthand in `ARIS_Rewrite_Document_Plan.md` (`src/ARIS.Core`, `src/ARIS.UI`, `tests/Core.Tests`, `tests/UI.Tests`) is **logically mapped** to the layered structure above. Where there’s any naming discrepancy, this Phase 0 execution document takes precedence. 
* Backend projects follow the layered architecture in `ARIS_Backend_SDD.md` while still giving you a clear `ARIS.UI` host and `frontend/` app as in the plan. 

---

## 4. Implementation Steps

### 4.1 Create solution and projects

**Objective:** Have a compiling .NET 8 solution with all projects created and referenced correctly.

**Steps:**

1. **Create `src/ARIS.sln`**

   * Use `dotnet new sln -n ARIS` in `src/`.

2. **Create backend projects (class libraries)**

   For each of these, use `dotnet new classlib -n <Name> -f net8.0`:

   * `Aris.Core`
   * `Aris.Application`
   * `Aris.Infrastructure`
   * `Aris.Adapters`
   * `Aris.Contracts`
   * `Aris.Tools`

   Set **`ImplicitUsings` enabled** and **`Nullable` enabled** in each `.csproj`.

3. **Create backend host project**

   * `Aris.Hosting`: use `dotnet new web -n Aris.Hosting -f net8.0` or `dotnet new worker` depending on how you want to host Kestrel.
   * The goal in Phase 0: a minimal HTTP/JSON endpoint surface and the ability to start up and shut down cleanly, following the backend SDD’s IPC/HTTP bridge section (we do **not** add real operations yet). 

4. **Create UI host project**

   * `ARIS.UI`: use `dotnet new wpf -n ARIS.UI -f net8.0` or `dotnet new winforms` depending on preferred WebView2 hosting approach.
   * Add WebView2 NuGet packages but only configure a minimal host window and WebView2 control in Phase 0. The goal is to be ready to point WebView2 at `frontend/dist/index.html` later. 

5. **Create test projects**

   * `Aris.Core.Tests`: `dotnet new xunit -n Aris.Core.Tests -f net8.0`
   * `ARIS.UI.Tests`: `dotnet new xunit -n ARIS.UI.Tests -f net8.0`

   Add references:

   * `Aris.Core.Tests` → `Aris.Core`, `Aris.Application`
   * `ARIS.UI.Tests` → `ARIS.UI`, potentially `Aris.Hosting` if you’re testing IPC wiring.

6. **Add projects to solution and wire references**

   * Add all projects to `ARIS.sln` with `dotnet sln ARIS.sln add ...`.
   * Add references:

     * `Aris.Application` → `Aris.Core`
     * `Aris.Infrastructure` → `Aris.Core`
     * `Aris.Adapters` → `Aris.Application`, `Aris.Core`, `Aris.Infrastructure` (if needed)
     * `Aris.Hosting` → `Aris.Application`, `Aris.Infrastructure`, `Aris.Adapters`, `Aris.Contracts`, `Aris.Tools`
     * `ARIS.UI` → `Aris.Hosting` (or whichever host assembly exposes IPC client contracts)

**Acceptance criteria:**

* `dotnet build` from `src/` succeeds without warnings or errors that indicate missing references.

---

### 4.2 Minimal DI and configuration skeleton

**Objective:** Establish a basic DI container and configuration pipeline that matches the design SDDs but only with placeholder services. 

**Steps:**

1. In `Aris.Hosting`:

   * Use the **generic host builder** (`Host.CreateDefaultBuilder`) to:

     * Bind configuration from `appsettings.json` and environment-specific variants (`appsettings.Development.json`, etc.). 
     * Register logging via `Microsoft.Extensions.Logging`.

   * Add an extension method like `services.AddArisBackend()` which:

     * Registers `Aris.Core`, `Aris.Application`, `Aris.Infrastructure`, `Aris.Adapters`, `Aris.Contracts` services in a **minimal placeholder** fashion (e.g., a simple workspace service stub, dummy tool registry).
     * This phase should **not implement real command handlers**; only scaffolding interfaces and dummy implementations that log “not implemented” when called.

2. In `Aris.Infrastructure`:

   * Create placeholder **interfaces and basic implementations** for:

     * Configuration access (`IAppConfiguration`, wrapping `IConfiguration`).
     * Logging helpers (thin wrappers around `ILogger<T>` if needed).
     * File system abstraction (minimal, just enough to be extended later).

3. Generate an `appsettings.json` in `Aris.Hosting` containing:

   * Logging defaults (to console and file, as per high-level design). 
   * A stub `ToolingOptions` and `WorkspaceOptions` section with no real paths yet. 

**Acceptance criteria:**

* `Aris.Hosting` can start a host (e.g., `Program.cs` main) and shut down cleanly.
* Starting the backend writes at least one structured log line to console and/or file.

---

### 4.3 Logging scaffolding

**Objective:** Configure logging according to the backend SDD’s expectations, but with minimal sinks. 

**Steps:**

1. Configure logging with `Microsoft.Extensions.Logging` in `Aris.Hosting`:

   * Console logger for development.
   * Rolling file logger path under `%LOCALAPPDATA%/ARIS/logs/` (Phase 0: simple implementation is fine). 

2. Introduce an `OperationId`/`CorrelationId` concept as a **value object type** in `Aris.Core` but keep it unused or minimally used in Phase 0 (log a single operation id on startup/shutdown). 

3. Ensure log messages are structured (use named properties, not string concatenation) to match observability goals. 

**Acceptance criteria:**

* Starting the backend produces structured logs containing at least:

  * Timestamp
  * Log level
  * Category
  * Operation or correlation id (even if fake)
  * Message indicating ARIS backend started successfully.

---

### 4.4 Tool extraction subsystem (stub)

**Objective:** Create the **structure** for dependency embedding and extraction without shipping real binaries or complete logic yet. 

**Steps:**

1. In `Aris.Tools`:

   * Add a placeholder manifest file (e.g., `tools.manifest.json`) describing the **schema** but with dummy entries.
   * Create a static class (e.g., `ToolManifestIndex`) that can load and enumerate entries.

2. In `Aris.Infrastructure`:

   * Implement a stub `DependencyExtractor` service with methods like:

     * `Task PrepareToolsAsync(CancellationToken cancellationToken)`
     * `Task<bool> ValidateToolsAsync(CancellationToken cancellationToken)`

   The Phase 0 implementation can:

   * Create the target extraction root: `%LOCALAPPDATA%/ARIS/tools/{version}/` (use a dummy version). 
   * Log that extraction would occur, but **does not need to extract real binaries** yet.

3. Wire the stub into `Aris.Hosting`:

   * On startup, call `PrepareToolsAsync` and log the result.
   * If stubbed, always return success, but make the call path explicit for later implementation.

**Acceptance criteria:**

* Backend startup triggers the stub dependency preparation logic and logs what it would do.
* No hard-coded paths outside `%LOCALAPPDATA%/ARIS/tools/...` exist. 

---

### 4.5 Frontend scaffold (React/TS/Tailwind)

**Objective:** Create a minimal frontend project that compiles and can be built into `frontend/dist/`, using React/TypeScript/Tailwind. 

**Steps:**

1. In `frontend/`:

   * Initialize package.json with:

     * React, ReactDOM
     * TypeScript
     * Tailwind CSS
     * Vite (or similar modern bundler)
   * Run the appropriate scaffolding command (e.g., `npm create vite@latest` then adapt) to produce a TypeScript React starter app.

2. Configure **Tailwind**:

   * `tailwind.config.js` referencing `./index.html`, `./src/**/*.{ts,tsx,js,jsx}`.
   * `postcss.config.cjs` with Tailwind + autoprefixer.

3. Create a minimal `src/App.tsx`:

   * For Phase 0, just render a simple “ARIS Frontend – Phase 0 Scaffolding” screen.
   * No backend integration, no routing yet.

4. Add npm scripts:

   * `"dev"` – dev server
   * `"build"` – production build output to `dist/`
   * `"preview"` – preview built assets

**Acceptance criteria:**

* `npm install` and `npm run build` in `frontend/` succeed.
* `frontend/dist/` contains a build suitable to be served by WebView2.

---

### 4.6 WebView2 host wiring (minimal)

**Objective:** Configure `ARIS.UI` to host WebView2 and load the built frontend from `frontend/dist/` (file or local HTTP), but without real backend integration yet. 

**Steps:**

1. In `ARIS.UI`:

   * Add a WebView2 control to the main window/form.
   * For Phase 0, point WebView2 at:

     * Either a `file:///` URI to the `frontend/dist/index.html` path, or
     * A local dev server URL (e.g., `http://localhost:5173`) if that’s easier for early development.

2. Add a simple status bar or label showing:

   * “Backend: not connected (Phase 0)”
   * This is just to visually confirm the host runs.

3. Ensure that building and running `ARIS.UI` shows the Phase 0 frontend screen.

**Acceptance criteria:**

* Running `ARIS.UI` presents a window with the built frontend displayed successfully.
* No backend calls are made yet.

---

### 4.7 Single-file publish sanity check

**Objective:** Validate that the Phase 0 solution can be published as a single-file, self-contained app at least once.  

**Steps:**

1. Choose a primary host to publish:

   * For Phase 0, you can:

     * Publish `Aris.Hosting` as a console/web host, **or**
     * Publish `ARIS.UI` as the desktop entrypoint, depending on packaging strategy.

2. From the appropriate project folder, run:

   ```
   dotnet publish -c Release -r win-x64 --self-contained true /p:PublishSingleFile=true
   ```

   (You may optionally include `/p:EnableCompressionInSingleFile=true` later as per backend SDD.) 

3. Verify:

   * A single executable is produced.
   * Running the executable starts the app without crashing (tool extraction is stubbed and should not fail).

**Acceptance criteria:**

* Single-file publish completes without errors.
* Executable launches and reaches the same behavior as debug runs (host and, if applicable, UI).

---

## 5. Definition of Done (Phase 0)

Phase 0 is complete when **all** of the following are true:

1. Solution structure:

   * `src/ARIS.sln` exists and includes all backend + host projects.
   * `tests/Aris.Core.Tests` and `tests/ARIS.UI.Tests` exist and compile (even with only placeholder tests).
   * `frontend/` React/TS/Tailwind app builds successfully.  

2. Backend host:

   * `Aris.Hosting` starts and stops cleanly.
   * Logging and configuration pipeline is established (basic `appsettings.json`, console/file logging).  

3. Tool extraction subsystem:

   * `Aris.Tools` and a stub manifest exist.
   * A `DependencyExtractor` (or equivalent) service exists and is invoked at startup, even if it only logs stub behavior. 

4. UI host:

   * `ARIS.UI` launches a window.
   * WebView2 loads the built frontend (or dev server) and displays a Phase 0 placeholder UI. 

5. Packaging:

   * At least one successful **single-file publish** has been performed and validated by running the output binary. 

---

## 6. Notes and Non-Goals

* Do **not** implement:

  * Retoc/UAssetAPI/UWPDumper/DLL Injector logic.
  * Real workspace operations, command handlers, or Unreal-specific flows.
* Phase 0 is strictly about:

  * Getting the **scaffolding, layout, and basic runtime behavior** in place.
  * Making sure the project is ready for the more detailed work in Phases 1–7.

If any ambiguities arise between this document and the SDDs, prefer:

1. **Backend SDD** for internal layering & architecture. 
2. **High-Level SDD** for deployment, security, and overall posture. 
3. Ask the user to clarify when behavior or naming is still unclear.

---